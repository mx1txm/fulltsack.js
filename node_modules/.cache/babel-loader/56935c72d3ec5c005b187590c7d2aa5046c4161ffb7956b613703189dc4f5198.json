{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport \"./fixPolyfills.js\";\nimport { wrap } from 'optimism';\nimport { equal } from '@wry/equality';\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { defaultDataIdFromObject, Policies } from \"./policies.js\";\nimport { hasOwn } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  typePolicies: {}\n};\nvar InMemoryCache = function (_super) {\n  __extends(InMemoryCache, _super);\n  function InMemoryCache(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.watches = new Set();\n    _this.typenameDocumentCache = new Map();\n    _this.makeVar = makeVar;\n    _this.txCount = 0;\n    _this.config = __assign(__assign({}, defaultConfig), config);\n    _this.addTypename = !!_this.config.addTypename;\n    _this.policies = new Policies({\n      cache: _this,\n      dataIdFromObject: _this.config.dataIdFromObject,\n      possibleTypes: _this.config.possibleTypes,\n      typePolicies: _this.config.typePolicies\n    });\n    _this.init();\n    return _this;\n  }\n  InMemoryCache.prototype.init = function () {\n    var rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching\n    });\n    this.optimisticData = rootStore.stump;\n    this.resetResultCache();\n  };\n  InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n    var _this = this;\n    var previousReader = this.storeReader;\n    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({\n      cache: this,\n      addTypename: this.addTypename,\n      resultCacheMaxSize: this.config.resultCacheMaxSize,\n      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon\n    }));\n    this.maybeBroadcastWatch = wrap(function (c, options) {\n      return _this.broadcastWatch(c, options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: function (c) {\n        var store = c.optimistic ? _this.optimisticData : _this.data;\n        if (supportsResultCaching(store)) {\n          var optimistic = c.optimistic,\n            rootId = c.rootId,\n            variables = c.variables;\n          return store.makeCacheKey(c.query, c.callback, canonicalStringify({\n            optimistic: optimistic,\n            rootId: rootId,\n            variables: variables\n          }));\n        }\n      }\n    });\n    new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n      return group.resetCaching();\n    });\n  };\n  InMemoryCache.prototype.restore = function (data) {\n    this.init();\n    if (data) this.data.replace(data);\n    return this;\n  };\n  InMemoryCache.prototype.extract = function (optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return (optimistic ? this.optimisticData : this.data).extract();\n  };\n  InMemoryCache.prototype.read = function (options) {\n    var _a = options.returnPartialData,\n      returnPartialData = _a === void 0 ? false : _a;\n    try {\n      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n        store: options.optimistic ? this.optimisticData : this.data,\n        config: this.config,\n        returnPartialData: returnPartialData\n      })).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        return null;\n      }\n      throw e;\n    }\n  };\n  InMemoryCache.prototype.write = function (options) {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.modify = function (options) {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      return false;\n    }\n    var store = options.optimistic ? this.optimisticData : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.diff = function (options) {\n    return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config\n    }));\n  };\n  InMemoryCache.prototype.watch = function (watch) {\n    var _this = this;\n    if (!this.watches.size) {\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return function () {\n      if (_this.watches.delete(watch) && !_this.watches.size) {\n        forgetCache(_this);\n      }\n      _this.maybeBroadcastWatch.forget(watch);\n    };\n  };\n  InMemoryCache.prototype.gc = function (options) {\n    canonicalStringify.reset();\n    var ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  };\n  InMemoryCache.prototype.retain = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  };\n  InMemoryCache.prototype.release = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  };\n  InMemoryCache.prototype.identify = function (object) {\n    return isReference(object) ? object.__ref : this.policies.identify(object)[0];\n  };\n  InMemoryCache.prototype.evict = function (options) {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        return false;\n      }\n      options = __assign(__assign({}, options), {\n        id: \"ROOT_QUERY\"\n      });\n    }\n    try {\n      ++this.txCount;\n      return this.optimisticData.evict(options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n  InMemoryCache.prototype.reset = function () {\n    this.init();\n    this.broadcastWatches();\n    canonicalStringify.reset();\n    return Promise.resolve();\n  };\n  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  };\n  InMemoryCache.prototype.batch = function (options) {\n    var _this = this;\n    var update = options.update,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      removeOptimistic = options.removeOptimistic,\n      onWatchUpdated = options.onWatchUpdated;\n    var perform = function (layer) {\n      var _a = _this,\n        data = _a.data,\n        optimisticData = _a.optimisticData;\n      ++_this.txCount;\n      if (layer) {\n        _this.data = _this.optimisticData = layer;\n      }\n      try {\n        update(_this);\n      } finally {\n        --_this.txCount;\n        _this.data = data;\n        _this.optimisticData = optimisticData;\n      }\n    };\n    var alreadyDirty = new Set();\n    if (onWatchUpdated && !this.txCount) {\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch) {\n          alreadyDirty.add(watch);\n          return false;\n        }\n      }));\n    }\n    if (typeof optimistic === 'string') {\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      perform(this.data);\n    } else {\n      perform();\n    }\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch, diff) {\n          var result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        }\n      }));\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(function (watch) {\n          return _this.maybeBroadcastWatch.dirty(watch);\n        });\n      }\n    } else {\n      this.broadcastWatches(options);\n    }\n  };\n  InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n    return this.batch({\n      update: update,\n      optimistic: optimisticId || optimisticId !== null\n    });\n  };\n  InMemoryCache.prototype.transformDocument = function (document) {\n    if (this.addTypename) {\n      var result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  };\n  InMemoryCache.prototype.broadcastWatches = function (options) {\n    var _this = this;\n    if (!this.txCount) {\n      this.watches.forEach(function (c) {\n        return _this.maybeBroadcastWatch(c, options);\n      });\n    }\n  };\n  InMemoryCache.prototype.broadcastWatch = function (c, options) {\n    var lastDiff = c.lastDiff;\n    var diff = this.diff({\n      query: c.query,\n      variables: c.variables,\n      optimistic: c.optimistic\n    });\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        return;\n      }\n    }\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  };\n  return InMemoryCache;\n}(ApolloCache);\nexport { InMemoryCache };","map":{"version":3,"names":["wrap","equal","ApolloCache","MissingFieldError","addTypenameToDocument","isReference","StoreReader","StoreWriter","EntityStore","supportsResultCaching","makeVar","forgetCache","recallCache","defaultDataIdFromObject","Policies","hasOwn","canonicalStringify","defaultConfig","dataIdFromObject","addTypename","resultCaching","typePolicies","InMemoryCache","_super","__extends","config","_this","call","watches","Set","typenameDocumentCache","Map","txCount","__assign","policies","cache","possibleTypes","init","prototype","rootStore","data","Root","optimisticData","stump","resetResultCache","resetResultIdentities","previousReader","storeReader","storeWriter","resultCacheMaxSize","canon","maybeBroadcastWatch","c","options","broadcastWatch","max","makeCacheKey","store","optimistic","rootId","variables","query","callback","group","forEach","resetCaching","restore","replace","extract","read","_a","returnPartialData","diffQueryAgainstStore","result","e","write","writeToStore","broadcast","broadcastWatches","modify","id","fields","diff","watch","size","add","immediate","delete","forget","gc","reset","ids","resetCanon","retain","release","identify","object","__ref","evict","Promise","resolve","removeOptimistic","idToRemove","newOptimisticData","removeLayer","batch","update","onWatchUpdated","perform","layer","alreadyDirty","addLayer","dirty","performTransaction","optimisticId","transformDocument","document","get","set","lastDiff","fromOptimisticTransaction"],"sources":["/Users/meltem/PycharmProjects/fullstack-js/node_modules/@apollo/src/cache/inmemory/inMemoryCache.ts"],"sourcesContent":["// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\nimport { OptimisticWrapperFunction, wrap } from 'optimism';\nimport { equal } from '@wry/equality';\n\nimport { ApolloCache } from '../core/cache';\nimport { Cache } from '../core/types/Cache';\nimport { MissingFieldError } from '../core/types/common';\nimport {\n  addTypenameToDocument,\n  StoreObject,\n  Reference,\n  isReference,\n} from '../../utilities';\nimport {\n  ApolloReducerConfig,\n  NormalizedCacheObject,\n} from './types';\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { EntityStore, supportsResultCaching } from './entityStore';\nimport { makeVar, forgetCache, recallCache } from './reactiveVars';\nimport {\n  defaultDataIdFromObject,\n  PossibleTypesMap,\n  Policies,\n  TypePolicies,\n} from './policies';\nimport { hasOwn } from './helpers';\nimport { canonicalStringify } from './object-canon';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  possibleTypes?: PossibleTypesMap;\n  typePolicies?: TypePolicies;\n  resultCacheMaxSize?: number;\n}\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  | \"optimistic\"\n  | \"onWatchUpdated\"\n>\n\nconst defaultConfig: InMemoryCacheConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  typePolicies: {},\n};\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: EntityStore;\n  private optimisticData: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n\n  private maybeBroadcastWatch: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]>;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    });\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canon: resetResultIdentities\n          ? void 0\n          : previousReader && previousReader.canon,\n      }),\n    );\n\n    this.maybeBroadcastWatch = wrap((\n      c: Cache.WatchOptions,\n      options?: BroadcastOptions,\n    ) => {\n      return this.broadcastWatch(c, options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: (c: Cache.WatchOptions) => {\n        // Return a cache key (thus enabling result caching) only if we're\n        // currently using a data store that can track cache dependencies.\n        const store = c.optimistic ? this.optimisticData : this.data;\n        if (supportsResultCaching(store)) {\n          const { optimistic, rootId, variables } = c;\n          return store.makeCacheKey(\n            c.query,\n            // Different watches can have the same query, optimistic\n            // status, rootId, and variables, but if their callbacks are\n            // different, the (identical) result needs to be delivered to\n            // each distinct callback. The easiest way to achieve that\n            // separation is to include c.callback in the cache key for\n            // maybeBroadcastWatch calls. See issue #5733.\n            c.callback,\n            canonicalStringify({ optimistic, rootId, variables }),\n          );\n        }\n      }\n    });\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([\n      this.data.group,\n      this.optimisticData.group,\n    ]).forEach(group => group.resetCaching());\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return this.storeReader.diffQueryAgainstStore<T>({\n        ...options,\n        store: options.optimistic ? this.optimisticData : this.data,\n        config: this.config,\n        returnPartialData,\n      }).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not\n        // need to worry about catching \"normal\" exceptions resulting from\n        // incomplete cache data. Unexpected errors will be re-thrown. If\n        // you need more information about which fields were missing, use\n        // cache.diff instead, and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify(options: Cache.ModifyOptions): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store = options.optimistic // Defaults to false.\n      ? this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<T>(options: Cache.DiffOptions): Cache.DiffResult<T> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    resetResultIdentities?: boolean;\n  }) {\n    canonicalStringify.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    return isReference(object) ? object.__ref :\n      this.policies.identify(object)[0];\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      return this.optimisticData.evict(options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(): Promise<void> {\n    this.init();\n    this.broadcastWatches();\n    canonicalStringify.reset();\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch(options: Cache.BatchOptions<InMemoryCache>) {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    const perform = (layer?: EntityStore) => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        update(this);\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === 'string') {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        }\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(watch => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null,\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || (optimisticId !== null),\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(\n    c: Cache.WatchOptions,\n    options?: BroadcastOptions,\n  ) {\n    const { lastDiff } = c;\n    const diff = this.diff<any>({\n      query: c.query,\n      variables: c.variables,\n      optimistic: c.optimistic,\n    });\n\n    if (options) {\n      if (c.optimistic &&\n          typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (options.onWatchUpdated &&\n          options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}