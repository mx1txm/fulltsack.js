{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { createFragmentMap, getFragmentFromSelection, getDefaultValues, getFragmentDefinitions, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument } from \"../../utilities/index.js\";\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\n;\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader) {\n    this.cache = cache;\n    this.reader = reader;\n  }\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n    var query = _a.query,\n      result = _a.result,\n      dataId = _a.dataId,\n      variables = _a.variables,\n      overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var context = {\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables),\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false\n    };\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n    if (!isReference(ref)) {\n      throw __DEV__ ? new InvariantError(\"Could not identify object \" + JSON.stringify(result)) : new InvariantError(8);\n    }\n    context.incomingById.forEach(function (_a, dataId) {\n      var fields = _a.fields,\n        mergeTree = _a.mergeTree,\n        selections = _a.selections;\n      var entityRef = makeReference(dataId);\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, fields, context);\n        if (isReference(applied)) {\n          return;\n        }\n        fields = applied;\n      }\n      if (__DEV__ && !context.overwrite) {\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1.has(fieldNameFromStoreName(storeFieldName));\n        };\n        var fieldsWithSelectionSets_1 = new Set();\n        selections.forEach(function (selection) {\n          if (isField(selection) && selection.selectionSet) {\n            fieldsWithSelectionSets_1.add(selection.name.value);\n          }\n        });\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n        Object.keys(fields).forEach(function (storeFieldName) {\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, fields, storeFieldName, context.store);\n          }\n        });\n      }\n      store.merge(dataId, fields);\n    });\n    store.retain(ref.__ref);\n    return ref;\n  };\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n    var dataId = _a.dataId,\n      result = _a.result,\n      selectionSet = _a.selectionSet,\n      context = _a.context,\n      mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    var _b = policies.identify(result, selectionSet, context.fragmentMap),\n      id = _b[0],\n      keyObject = _b[1];\n    dataId = dataId || id;\n    if (\"string\" === typeof dataId) {\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      var ref = makeReference(dataId);\n      if (sets.indexOf(selectionSet) >= 0) return ref;\n      sets.push(selectionSet);\n      if (this.reader && this.reader.isFresh(result, ref, selectionSet, context)) {\n        return ref;\n      }\n    }\n    var incomingFields = Object.create(null);\n    if (keyObject) {\n      incomingFields = context.merge(incomingFields, keyObject);\n    }\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n    if (\"string\" === typeof typename) {\n      incomingFields.__typename = typename;\n    }\n    var selections = new Set(selectionSet.selections);\n    selections.forEach(function (selection) {\n      var _a;\n      if (!shouldInclude(selection, context.variables)) return;\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n        var wasClientOnly = context.clientOnly;\n        context.clientOnly = wasClientOnly || !!(selection.directives && selection.directives.some(function (d) {\n          return d.name.value === \"client\";\n        }));\n        if (value !== void 0) {\n          var storeFieldName = policies.getStoreFieldName({\n            typename: typename,\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables\n          });\n          var childTree = getChildMergeTree(mergeTree, storeFieldName);\n          var incomingValue = _this.processFieldValue(value, selection, context, childTree);\n          var childTypename = void 0;\n          if (selection.selectionSet) {\n            childTypename = context.store.getFieldValue(incomingValue, \"__typename\");\n            if (!childTypename && isReference(incomingValue)) {\n              var info = context.incomingById.get(incomingValue.__ref);\n              childTypename = info && info.fields.__typename;\n            }\n          }\n          var merge = policies.getMergeFunction(typename, selection.name.value, childTypename);\n          if (merge) {\n            childTree.info = {\n              field: selection,\n              typename: typename,\n              merge: merge\n            };\n          } else {\n            maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n          }\n          incomingFields = context.merge(incomingFields, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n        } else if (!context.clientOnly && !addTypenameToDocument.added(selection)) {\n          __DEV__ && invariant.error((\"Missing field '\" + resultKeyNameFromField(selection) + \"' while writing result \" + JSON.stringify(result, null, 2)).substring(0, 1000));\n        }\n        context.clientOnly = wasClientOnly;\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n        if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n          fragment.selectionSet.selections.forEach(selections.add, selections);\n        }\n      }\n    });\n    if (\"string\" === typeof dataId) {\n      var previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.fields = context.merge(previous.fields, incomingFields);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        previous.selections.forEach(selections.add, selections);\n        previous.selections = selections;\n      } else {\n        context.incomingById.set(dataId, {\n          fields: incomingFields,\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          selections: selections\n        });\n      }\n      return makeReference(dataId);\n    }\n    return incomingFields;\n  };\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n    if (!field.selectionSet || value === null) {\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n    if (Array.isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n    var _this = this;\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 = !Array.isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      var i_1 = incoming;\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n      var changedFields_1;\n      var getValue_1 = function (from, name) {\n        return Array.isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n      if (changedFields_1) {\n        incoming = Array.isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n    return incoming;\n  };\n  return StoreWriter;\n}();\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n  return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n  return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = parentType + \".\" + fieldName;\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  if (!Array.isArray(existing) && !Array.isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  __DEV__ && invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\n}","map":{"version":3,"names":["invariant","InvariantError","equal","createFragmentMap","getFragmentFromSelection","getDefaultValues","getFragmentDefinitions","getOperationDefinition","getTypenameFromResult","makeReference","isField","resultKeyNameFromField","isReference","shouldInclude","cloneDeep","addTypenameToDocument","makeProcessedFieldsMerger","fieldNameFromStoreName","storeValueIsStoreObject","canonicalStringify","StoreWriter","cache","reader","prototype","writeToStore","store","_a","_this","query","result","dataId","variables","overwrite","operationDefinition","merger","__assign","context","written","Object","create","merge","existing","incoming","varString","fragmentMap","incomingById","Map","clientOnly","ref","processSelectionSet","selectionSet","mergeTree","map","__DEV__","JSON","stringify","forEach","fields","selections","entityRef","size","applied","applyMerges","hasSelectionSet_1","storeFieldName","fieldsWithSelectionSets_1","has","Set","selection","add","name","value","hasMergeFunction_1","childTree","get","Boolean","info","keys","warnAboutDataLoss","retain","__ref","policies","_b","identify","id","keyObject","sets","indexOf","push","isFresh","incomingFields","typename","rootTypenamesById","__typename","resultFieldKey","wasClientOnly","directives","some","d","getStoreFieldName","fieldName","field","getChildMergeTree","incomingValue","processFieldValue","childTypename","getFieldValue","getMergeFunction","maybeRecycleChildMergeTree","added","error","substring","fragment","fragmentMatches","previous","mergeMergeTrees","set","mergeTreeIsEmpty","Array","isArray","item","i","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","from","String","eVal","iVal","aVal","pop","slice","runMergeFunction","getStorage","apply","emptyMergeTreePool","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","key","delete","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","every","parentType","typeDotName","childTypenames","includes","warn","length","join"],"sources":["/Users/meltem/PycharmProjects/fullstack-js/node_modules/@apollo/src/cache/inmemory/writeToStore.ts"],"sourcesContent":["import { SelectionSetNode, FieldNode, SelectionNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\n\nimport {\n  createFragmentMap,\n  FragmentMap,\n  getFragmentFromSelection,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  Reference,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n} from '../../utilities';\n\nimport { NormalizedCache, ReadMergeModifyContext, MergeTree } from './types';\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject } from './helpers';\nimport { StoreReader } from './readFromStore';\nimport { InMemoryCache } from './inMemoryCache';\nimport { EntityStore } from './entityStore';\nimport { Cache } from '../../core';\nimport { canonicalStringify } from './object-canon';\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap?: FragmentMap;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<string, {\n    fields: StoreObject;\n    mergeTree?: MergeTree;\n    selections: Set<SelectionNode>;\n  }>;\n  clientOnly: boolean;\n};\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string,\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n  ) {}\n\n  public writeToStore(store: NormalizedCache, {\n    query,\n    result,\n    dataId,\n    variables,\n    overwrite,\n  }: Cache.WriteOptions): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      overwrite: !!overwrite,\n      incomingById: new Map,\n      clientOnly: false,\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw new InvariantError(`Could not identify object ${JSON.stringify(result)}`);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(({ fields, mergeTree, selections }, dataId) => {\n      const entityRef = makeReference(dataId);\n\n      if (mergeTree && mergeTree.map.size) {\n        const applied = this.applyMerges(mergeTree, entityRef, fields, context);\n        if (isReference(applied)) {\n          // Assume References returned by applyMerges have already been merged\n          // into the store. See makeMergeObjectsFunction in policies.ts for an\n          // example of how this can happen.\n          return;\n        }\n        // Otherwise, applyMerges returned a StoreObject, whose fields we should\n        // merge into the store (see store.merge statement below).\n        fields = applied;\n      }\n\n      if (__DEV__ && !context.overwrite) {\n        const hasSelectionSet = (storeFieldName: string) =>\n          fieldsWithSelectionSets.has(fieldNameFromStoreName(storeFieldName));\n        const fieldsWithSelectionSets = new Set<string>();\n        selections.forEach(selection => {\n          if (isField(selection) && selection.selectionSet) {\n            fieldsWithSelectionSets.add(selection.name.value);\n          }\n        });\n\n        const hasMergeFunction = (storeFieldName: string) => {\n          const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n\n        Object.keys(fields).forEach(storeFieldName => {\n          // If a merge function was defined for this field, trust that it\n          // did the right thing about (not) clobbering data. If the field\n          // has no selection set, it's a scalar field, so it doesn't need\n          // a merge function (even if it's an object, like JSON data).\n          if (hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)) {\n            warnAboutDataLoss(\n              entityRef,\n              fields,\n              storeFieldName,\n              context.store,\n            );\n          }\n        });\n      }\n\n      store.merge(dataId, fields);\n    });\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    const [id, keyObject] = policies.identify(\n      result, selectionSet, context.fragmentMap);\n\n    // If dataId was not provided, fall back to the id just generated by\n    // policies.identify.\n    dataId = dataId || id;\n\n    if (\"string\" === typeof dataId) {\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      const ref = makeReference(dataId);\n      if (sets.indexOf(selectionSet) >= 0) return ref;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (this.reader && this.reader.isFresh(\n        result,\n        ref,\n        selectionSet,\n        context,\n      )) {\n        return ref;\n      }\n    }\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incomingFields: StoreObject = Object.create(null);\n\n    // Write any key fields that were used during identification, even if\n    // they were not mentioned in the original query.\n    if (keyObject) {\n      incomingFields = context.merge(incomingFields, keyObject);\n    }\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && context.store.get(dataId, \"__typename\") as string);\n\n    if (\"string\" === typeof typename) {\n      incomingFields.__typename = typename;\n    }\n\n    const selections = new Set(selectionSet.selections);\n\n    selections.forEach(selection => {\n      if (!shouldInclude(selection, context.variables)) return;\n\n      if (isField(selection)) {\n        const resultFieldKey = resultKeyNameFromField(selection);\n        const value = result[resultFieldKey];\n\n        const wasClientOnly = context.clientOnly;\n        context.clientOnly = wasClientOnly || !!(\n          selection.directives &&\n          selection.directives.some(d => d.name.value === \"client\")\n        );\n\n        if (value !== void 0) {\n          const storeFieldName = policies.getStoreFieldName({\n            typename,\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n          });\n\n          const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n          let incomingValue =\n            this.processFieldValue(value, selection, context, childTree);\n\n          // To determine if this field holds a child object with a merge\n          // function defined in its type policy (see PR #7070), we need to\n          // figure out the child object's __typename.\n          let childTypename: string | undefined;\n\n          // The field's value can be an object that has a __typename only if\n          // the field has a selection set. Otherwise incomingValue is scalar.\n          if (selection.selectionSet) {\n            // We attempt to find the child __typename first in context.store,\n            // but the child object may not exist in the store yet, likely\n            // because it's being written for the first time, during this very\n            // call to writeToStore. Note: if incomingValue is a non-normalized\n            // StoreObject (not a Reference), getFieldValue will read from that\n            // object's properties to find its __typename.\n            childTypename = context.store.getFieldValue<string>(\n              incomingValue as StoreObject | Reference,\n              \"__typename\",\n            );\n\n            // If the child object is being written for the first time, but\n            // incomingValue is a Reference, then the entity that Reference\n            // identifies should have an entry in context.incomingById, which\n            // likely contains a __typename field we can use. After all, how\n            // could we know the object's ID if it had no __typename? If we\n            // wrote data into context.store as each processSelectionSet call\n            // finished processing an entity object, the child object would\n            // already be in context.store, so we wouldn't need this extra\n            // check, but holding all context.store.merge calls until after\n            // we've finished all processSelectionSet work is cleaner and solves\n            // other problems, such as issue #8370.\n            if (!childTypename && isReference(incomingValue)) {\n              const info = context.incomingById.get(incomingValue.__ref);\n              childTypename = info && info.fields.__typename;\n            }\n          }\n\n          const merge = policies.getMergeFunction(\n            typename,\n            selection.name.value,\n            childTypename,\n          );\n\n          if (merge) {\n            childTree.info = {\n              // TODO Check compatibility against any existing\n              // childTree.field?\n              field: selection,\n              typename,\n              merge,\n            };\n          } else {\n            maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n          }\n\n          incomingFields = context.merge(incomingFields, {\n            [storeFieldName]: incomingValue,\n          });\n\n        } else if (\n          !context.clientOnly &&\n          !addTypenameToDocument.added(selection)\n        ) {\n          invariant.error(`Missing field '${\n            resultKeyNameFromField(selection)\n          }' while writing result ${\n            JSON.stringify(result, null, 2)\n          }`.substring(0, 1000));\n        }\n\n        context.clientOnly = wasClientOnly;\n\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.fragmentMap,\n        );\n\n        if (fragment &&\n            // By passing result and context.variables, we enable\n            // policies.fragmentMatches to bend the rules when typename is\n            // not a known subtype of the fragment type condition, but the\n            // result object contains all the keys requested by the\n            // fragment, which strongly suggests the fragment probably\n            // matched. This fuzzy matching behavior must be enabled by\n            // including a regular expression string (such as \".*\" or\n            // \"Prefix.*\" or \".*Suffix\") in the possibleTypes array for\n            // specific supertypes; otherwise, all matching remains exact.\n            // Fuzzy matches are remembered by the Policies object and\n            // later used when reading from the cache. Since there is no\n            // incoming result object to check when reading, reading does\n            // not involve the same fuzzy inference, so the StoreReader\n            // class calls policies.fragmentMatches without passing result\n            // or context.variables. The flexibility of fuzzy matching\n            // allows existing clients to accommodate previously unknown\n            // __typename strings produced by server/schema changes, which\n            // would otherwise be breaking changes.\n            policies.fragmentMatches(fragment, typename, result, context.variables)) {\n          fragment.selectionSet.selections.forEach(selections.add, selections);\n        }\n      }\n    });\n\n    if (\"string\" === typeof dataId) {\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.fields = context.merge(previous.fields, incomingFields);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        // Add all previous SelectionNode objects, rather than creating a new\n        // Set, since the original unmerged selections Set is not going to be\n        // needed again (only the merged Set).\n        previous.selections.forEach(selections.add, selections);\n        previous.selections = selections;\n      } else {\n        context.incomingById.set(dataId, {\n          fields: incomingFields,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          selections,\n        });\n      }\n      return makeReference(dataId);\n    }\n\n    return incomingFields;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree,\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>,\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined = (\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        !Array.isArray(incoming) &&\n        // Likewise, existing must be either a Reference or a StoreObject\n        // in order for its fields to be safe to merge with the fields of\n        // the incoming object.\n        (isReference(existing) || storeValueIsStoreObject(existing))\n      ) ? existing : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number,\n      ): StoreValue => {\n        return Array.isArray(from)\n          ? (typeof name === \"number\" ? from[name] : void 0)\n          : context.store.getFieldValue(from, String(name))\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs,\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map;\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (Array.isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs),\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined,\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info = left.info && right.info ? {\n    ...left.info,\n    ...right.info,\n  } : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map = needToMergeMaps ? new Map :\n    left.map.size ? left.map : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(leftTree, right.map.get(key)),\n      );\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach(key => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(\n          right.map.get(key),\n          left.map.get(key),\n        ),\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache,\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (Object.keys(existing).every(\n    key => store.getFieldValue(incoming, key) !== void 0)) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!Array.isArray(existing) &&\n      !Array.isArray(incoming)) {\n    [existing, incoming].forEach(child => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" &&\n          !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n`Cache data may be lost when replacing the ${fieldName} field of a ${parentType} object.\n\nTo address this problem (which is not a bug in Apollo Client), ${\n  childTypenames.length\n    ? \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n    : \"\"\n}define a custom merge function for the ${\n  typeDotName\n} field, so InMemoryCache can safely merge these objects:\n\n  existing: ${JSON.stringify(existing).slice(0, 1000)}\n  incoming: ${JSON.stringify(incoming).slice(0, 1000)}\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}