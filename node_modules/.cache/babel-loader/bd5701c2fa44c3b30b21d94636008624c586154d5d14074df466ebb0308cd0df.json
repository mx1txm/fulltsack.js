{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { wrap } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isField, resultKeyNameFromField, isReference, makeReference, createFragmentMap, shouldInclude, addTypenameToDocument, getDefaultValues, getFragmentDefinitions, getMainDefinition, getQueryDefinition, mergeDeepArray, getFragmentFromSelection, maybeDeepFreeze, isNonNullObject, canUseWeakMap } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { getTypenameFromStoreObject } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { canonicalStringify, ObjectCanon } from \"./object-canon.js\";\n;\nfunction missingFromInvariant(err, context) {\n  return new MissingFieldError(err.message, context.path.slice(), context.query, context.variables);\n}\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context, options.context.canonizeResults];\n}\nvar StoreReader = function () {\n  function StoreReader(config) {\n    var _this = this;\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = __assign(__assign({}, config), {\n      addTypename: config.addTypename !== false\n    });\n    this.canon = config.canon || new ObjectCanon();\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      peekArgs[3] = !canonizeResults;\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            result: _this.canon.admit(other.result)\n          });\n        }\n        return other;\n      }\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n          array = _a.array,\n          context = _a.context;\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n      query = _a.query,\n      _b = _a.rootId,\n      rootId = _b === void 0 ? 'ROOT_QUERY' : _b,\n      variables = _a.variables,\n      _c = _a.returnPartialData,\n      returnPartialData = _c === void 0 ? true : _c,\n      _d = _a.canonizeResults,\n      canonizeResults = _d === void 0 ? true : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: []\n      }\n    });\n    var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing[0];\n    }\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields\n    };\n  };\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  };\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n    var selectionSet = _a.selectionSet,\n      objectOrReference = _a.objectOrReference,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: [missingFromInvariant(__DEV__ ? new InvariantError(\"Dangling reference to missing \" + objectOrReference.__ref + \" object\") : new InvariantError(5), context)]\n      };\n    }\n    var variables = context.variables,\n      policies = context.policies,\n      store = context.store;\n    var objectsToMerge = [];\n    var finalResult = {\n      result: null\n    };\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n    function handleMissing(result) {\n      var _a;\n      if (result.missing) (_a = getMissing()).push.apply(_a, result.missing);\n      return result.result;\n    }\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n      if (!shouldInclude(selection, variables)) return;\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(missingFromInvariant(__DEV__ ? new InvariantError(\"Can't find field '\" + selection.name.value + \"' on \" + (isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2))) : new InvariantError(6), context));\n          }\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef: enclosingRef,\n            context: context\n          }));\n        } else if (!selection.selectionSet) {\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }));\n        }\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_a = {}, _a[resultName] = fieldValue, _a));\n        }\n        invariant(context.path.pop() === resultName);\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var merged = mergeDeepArray(objectsToMerge);\n    finalResult.result = context.canonizeResults ? this.canon.admit(merged) : maybeDeepFreeze(merged);\n    this.knownResults.set(finalResult.result, selectionSet);\n    return finalResult;\n  };\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n    var field = _a.field,\n      array = _a.array,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    var missing;\n    function handleMissing(childResult, i) {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push.apply(missing, childResult.missing);\n      }\n      invariant(context.path.pop() === i);\n      return childResult.result;\n    }\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n    array = array.map(function (item, i) {\n      if (item === null) {\n        return null;\n      }\n      context.path.push(i);\n      if (Array.isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n      invariant(context.path.pop() === i);\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n  return StoreReader;\n}();\nexport { StoreReader };\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        __DEV__ ? invariant(!isReference(value), \"Missing selection set for object of type \" + getTypenameFromStoreObject(store, value) + \" returned for query field \" + field.name.value) : invariant(!isReference(value), 7);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"names":["wrap","invariant","InvariantError","isField","resultKeyNameFromField","isReference","makeReference","createFragmentMap","shouldInclude","addTypenameToDocument","getDefaultValues","getFragmentDefinitions","getMainDefinition","getQueryDefinition","mergeDeepArray","getFragmentFromSelection","maybeDeepFreeze","isNonNullObject","canUseWeakMap","maybeDependOnExistenceOfEntity","supportsResultCaching","getTypenameFromStoreObject","MissingFieldError","canonicalStringify","ObjectCanon","missingFromInvariant","err","context","message","path","slice","query","variables","execSelectionSetKeyArgs","options","selectionSet","objectOrReference","canonizeResults","StoreReader","config","_this","knownResults","WeakMap","Map","__assign","addTypename","canon","executeSelectionSet","peekArgs","other","_a","peek","apply","result","admit","store","enclosingRef","__ref","execSelectionSetImpl","max","resultCacheMaxSize","keyArgs","makeCacheKey","parent","varString","executeSubSelectedArray","execSubSelectedArrayImpl","field","array","prototype","resetCanon","diffQueryAgainstStore","_b","rootId","_c","returnPartialData","_d","policies","cache","rootRef","execResult","fragmentMap","hasMissingFields","missing","length","complete","isFresh","get","latest","isKnown","rootTypenamesById","has","empty","__DEV__","objectsToMerge","finalResult","typename","getFieldValue","rootIdsByTypename","push","__typename","getMissing","handleMissing","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","resultName","added","JSON","stringify","Array","isArray","pass","pop","fragment","fragmentMatches","add","merged","set","childResult","i","filter","canRead","map","item","assertSelectionSetForIdValue","workSet_1","Object","values"],"sources":["/Users/meltem/PycharmProjects/fullstack-js/node_modules/@apollo/src/cache/inmemory/readFromStore.ts"],"sourcesContent":["import {\n  DocumentNode,\n  FieldNode,\n  SelectionSetNode,\n} from 'graphql';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  isField,\n  resultKeyNameFromField,\n  Reference,\n  isReference,\n  makeReference,\n  StoreObject,\n  createFragmentMap,\n  FragmentMap,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  mergeDeepArray,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  isNonNullObject,\n  canUseWeakMap,\n} from '../../utilities';\nimport { Cache } from '../core/types/Cache';\nimport {\n  DiffQueryAgainstStoreOptions,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from './types';\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from './entityStore';\nimport { getTypenameFromStoreObject } from './helpers';\nimport { Policies } from './policies';\nimport { InMemoryCache } from './inMemoryCache';\nimport { MissingFieldError } from '../core/types/common';\nimport { canonicalStringify, ObjectCanon } from './object-canon';\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  path: (string | number)[];\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingFieldError[];\n};\n\nfunction missingFromInvariant(\n  err: InvariantError,\n  context: ReadContext,\n) {\n  return new MissingFieldError(\n    err.message,\n    context.path.slice(),\n    context.query,\n    context.variables,\n  );\n}\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache,\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canon?: ObjectCanon;\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions,\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionset\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]>;\n\n  private config: {\n    cache: InMemoryCache,\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n  };\n\n  private knownResults = new (\n    canUseWeakMap ? WeakMap : Map\n  )<Record<string, any>, SelectionSetNode>();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon;\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = {\n      ...config,\n      addTypename: config.addTypename !== false,\n    };\n\n    this.canon = config.canon || new ObjectCanon;\n\n    this.executeSelectionSet = wrap(options => {\n      const { canonizeResults } = options.context;\n\n      const peekArgs = execSelectionSetKeyArgs(options);\n\n      // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n      peekArgs[3] = !canonizeResults;\n\n      const other = this.executeSelectionSet.peek(...peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return {\n            ...other,\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: this.canon.admit(other.result),\n          };\n        }\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n\n      maybeDependOnExistenceOfEntity(\n        options.context.store,\n        options.enclosingRef.__ref,\n      );\n\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return this.execSelectionSetImpl(options);\n\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey(selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(\n            selectionSet,\n            isReference(parent) ? parent.__ref : parent,\n            context.varString,\n            canonizeResults,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      maybeDependOnExistenceOfEntity(\n        options.context.store,\n        options.enclosingRef.__ref,\n      );\n      return this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey({ field, array, context }) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(\n            field,\n            array,\n            context.varString,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = 'ROOT_QUERY',\n    variables,\n    returnPartialData = true,\n    canonizeResults = true,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: [],\n      },\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing![0];\n    }\n\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext,\n  ): boolean {\n    if (supportsResultCaching(context.store) &&\n        this.knownResults.get(result) === selectionSet) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result),\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (isReference(objectOrReference) &&\n        !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n        !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: [missingFromInvariant(\n          new InvariantError(\n            `Dangling reference to missing ${objectOrReference.__ref} object`\n          ),\n          context,\n        )],\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const objectsToMerge: { [key: string]: any }[] = [];\n    const finalResult: ExecResult = { result: null };\n    const typename = store.getFieldValue<string>(objectOrReference, \"__typename\");\n\n    if (this.config.addTypename &&\n        typeof typename === \"string\" &&\n        !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) getMissing().push(...result.missing);\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach(selection => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference,\n        }, context);\n\n        const resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(\n              missingFromInvariant(\n                new InvariantError(`Can't find field '${\n                  selection.name.value\n                }' on ${\n                  isReference(objectOrReference)\n                    ? objectOrReference.__ref + \" object\"\n                    : \"object \" + JSON.stringify(objectOrReference, null, 2)\n                }`),\n                context,\n              ),\n            );\n          }\n\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef,\n            context,\n          }));\n\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue as StoreObject | Reference,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context,\n          }));\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n\n        invariant(context.path.pop() === resultName);\n\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.fragmentMap,\n        );\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    const merged = mergeDeepArray(objectsToMerge);\n    finalResult.result = context.canonizeResults\n      ? this.canon.admit(merged)\n      // Since this.canon is normally responsible for freezing results (only in\n      // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(merged);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    this.knownResults.set(finalResult.result, selectionSet);\n\n    return finalResult;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingFieldError[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      context.path.push(i);\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          enclosingRef,\n          context,\n        }), i);\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context,\n        }), i);\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any,\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach(value => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type ${\n            getTypenameFromStoreObject(store, value)\n          } returned for query field ${field.name.value}`,\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}